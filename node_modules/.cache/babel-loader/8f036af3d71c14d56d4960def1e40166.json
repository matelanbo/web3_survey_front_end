{"ast":null,"code":"import { utils } from 'ethers';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function encodeCallData(call, chainId) {\n  let queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  if (!call) {\n    return undefined;\n  }\n\n  const {\n    contract,\n    method,\n    args\n  } = call;\n\n  if (!contract.address || !method) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n\n  try {\n    const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n    const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n    return {\n      address: contract.address,\n      data: contract.interface.encodeFunctionData(method, args),\n      chainId,\n      isStatic,\n      refreshPerBlocks\n    };\n  } catch (_b) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function getUniqueActiveCalls(requests) {\n  const unique = [];\n  const used = {};\n\n  for (const request of requests) {\n    if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n      unique.push(request);\n      used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n    }\n  }\n\n  return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function getCallsForUpdate(requests, options) {\n  const callsForUpdate = [];\n\n  for (const request of requests) {\n    if (options) {\n      if (options.chainId && options.chainId !== request.chainId) {\n        continue;\n      }\n\n      if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n        continue;\n      }\n\n      const currentBlock = options.blockNumber;\n\n      if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n        if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n          continue;\n        }\n      }\n    }\n\n    callsForUpdate.push(request);\n  }\n\n  return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function decodeCallResult(call, result) {\n  if (!result || !call) {\n    return undefined;\n  }\n\n  const {\n    value,\n    success\n  } = result;\n\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      const errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["utils","warnOnInvalidCall","call","contract","method","args","console","warn","address","encodeCallData","chainId","queryParams","undefined","isStatic","_a","refresh","refreshPerBlocks","data","interface","encodeFunctionData","getUniqueActiveCalls","requests","unique","used","request","toLowerCase","push","getCallsForUpdate","options","callsForUpdate","lastUpdatedBlockNumber","currentBlock","blockNumber","decodeCallResult","result","value","success","decodeFunctionResult","error","errorMessage","Interface","decodeFunctionData","Error"],"sources":["/Users/qianyisheng/Desktop/web3/brownie_test/web3_survey/front_end/node_modules/@usedapp/core/src/helpers/calls.ts"],"sourcesContent":["import { utils } from 'ethers'\nimport { Call } from '../hooks/useCall'\nimport { Awaited, ContractMethodNames, Falsy, TypedContract } from '../model/types'\nimport { RawCall, RawCallResult } from '../providers'\nimport { QueryParams } from '../constants/type/QueryParams'\nimport { ChainId } from '../constants/chainId'\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call: Call | Falsy) {\n  if (!call) {\n    return\n  }\n  const { contract, method, args } = call\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`)\n}\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function encodeCallData(call: Call | Falsy, chainId: number, queryParams: QueryParams = {}): RawCall | Falsy {\n  if (!call) {\n    return undefined\n  }\n  const { contract, method, args } = call\n  if (!contract.address || !method) {\n    warnOnInvalidCall(call)\n    return undefined\n  }\n  try {\n    const isStatic = queryParams.isStatic ?? queryParams.refresh === 'never'\n    const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined\n\n    return {\n      address: contract.address,\n      data: contract.interface.encodeFunctionData(method, args),\n      chainId,\n      isStatic,\n      refreshPerBlocks,\n    }\n  } catch {\n    warnOnInvalidCall(call)\n    return undefined\n  }\n}\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests: RawCall[]) {\n  const unique: RawCall[] = []\n  const used: Record<string, boolean> = {}\n  for (const request of requests) {\n    if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n      unique.push(request)\n      used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true\n    }\n  }\n  return unique\n}\n\nexport interface RefreshOptions {\n  blockNumber?: number\n  chainId?: ChainId\n}\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests: RawCall[], options?: RefreshOptions) {\n  const callsForUpdate: RawCall[] = []\n  for (const request of requests) {\n    if (options) {\n      if (options.chainId && options.chainId !== request.chainId) {\n        continue\n      }\n      if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n        continue\n      }\n      const currentBlock = options.blockNumber\n      if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n        if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n          continue\n        }\n      }\n    }\n    callsForUpdate.push(request)\n  }\n  return callsForUpdate\n}\n\n/**\n * Result of a multicall call.\n * @public\n */\nexport type CallResult<T extends TypedContract, MN extends ContractMethodNames<T>> =\n  | { value: Awaited<ReturnType<T['functions'][MN]>>; error: undefined }\n  | { value: undefined; error: Error }\n  | undefined\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult<T extends TypedContract, MN extends ContractMethodNames<T>>(\n  call: Call | Falsy,\n  result: RawCallResult\n): CallResult<T, MN> {\n  if (!result || !call) {\n    return undefined\n  }\n  const { value, success } = result\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value) as Awaited<\n          ReturnType<T['functions'][MN]>\n        >,\n        error: undefined,\n      }\n    } else {\n      const errorMessage: string = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0]\n      return {\n        value: undefined,\n        error: new Error(errorMessage),\n      }\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error as Error,\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}