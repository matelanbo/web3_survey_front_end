{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useState } from 'react';\nimport { providers } from 'ethers';\nimport { useConfig } from '../../../hooks';\nimport { ReadonlyNetworksContext } from './context';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { networkStatesReducer } from './reducer';\nimport { useWindow } from '../../window';\nconst {\n  Provider,\n  StaticJsonRpcProvider\n} = providers;\n\nconst getProviderFromConfig = urlOrProviderOrProviderFunction => {\n  if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n    return urlOrProviderOrProviderFunction;\n  }\n\n  if (typeof urlOrProviderOrProviderFunction === 'function') {\n    return urlOrProviderOrProviderFunction();\n  }\n\n  return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction);\n};\n\nexport const getProvidersFromConfig = readOnlyUrls => fromEntries(Object.entries(readOnlyUrls).map(_ref => {\n  let [chainId, urlOrProviderOrProviderFunction] = _ref;\n  return [chainId, getProviderFromConfig(urlOrProviderOrProviderFunction)];\n}));\nexport function ReadonlyNetworksProvider(_ref2) {\n  let {\n    providerOverrides = {},\n    children\n  } = _ref2;\n  const {\n    readOnlyUrls = {},\n    pollingInterval,\n    pollingIntervals\n  } = useConfig();\n  const {\n    isActive\n  } = useWindow();\n  const [providers, setProviders] = useState(() => Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, Object.assign({}, fromEntries(Object.keys(Object.assign(Object.assign({}, readOnlyUrls), providerOverrides)).map(chainId => [chainId, {\n    nonStaticCalls: 0\n  }]))));\n  const getPollingInterval = useCallback(chainId => {\n    var _a;\n\n    return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval;\n  }, [pollingInterval, pollingIntervals]);\n  useEffect(() => {\n    setProviders(Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  }, Object.entries(readOnlyUrls).flat());\n  useEffect(() => {\n    for (const [chainId, {\n      nonStaticCalls\n    }] of Object.entries(networkStates)) {\n      const provider = providers[chainId];\n\n      if (provider) {\n        provider.polling = isActive && nonStaticCalls > 0;\n      }\n    }\n  }, [networkStates, isActive]);\n  useEffect(() => {\n    for (const [chainId, provider] of Object.entries(providers)) {\n      provider.pollingInterval = getPollingInterval(Number(chainId));\n    }\n  }, [providers, getPollingInterval]);\n  const networks = useMemo(() => ({\n    providers,\n    updateNetworkState: dispatchNetworkState\n  }), [providers, dispatchNetworkState]);\n  return _jsx(ReadonlyNetworksContext.Provider, Object.assign({\n    value: networks\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useMemo","useReducer","useState","providers","useConfig","ReadonlyNetworksContext","fromEntries","networkStatesReducer","useWindow","Provider","StaticJsonRpcProvider","getProviderFromConfig","urlOrProviderOrProviderFunction","isProvider","getProvidersFromConfig","readOnlyUrls","Object","entries","map","chainId","ReadonlyNetworksProvider","providerOverrides","children","pollingInterval","pollingIntervals","isActive","setProviders","networkStates","dispatchNetworkState","keys","nonStaticCalls","getPollingInterval","_a","flat","provider","polling","Number","networks","updateNetworkState","_jsx","value"],"sources":["/Users/qianyisheng/Desktop/web3/brownie_test/web3_survey/front_end/node_modules/@usedapp/core/src/providers/network/readonlyNetworks/provider.tsx"],"sourcesContent":["import { ReactNode, useCallback, useEffect, useMemo, useReducer, useState } from 'react'\nimport { providers } from 'ethers'\nimport { useConfig } from '../../../hooks'\nimport { Providers } from './model'\nimport { ReadonlyNetworksContext } from './context'\nimport { BaseProviderFactory, ChainId, NodeUrls } from '../../../constants'\nimport { fromEntries } from '../../../helpers/fromEntries'\nimport { networkStatesReducer } from './reducer'\nimport { useWindow } from '../../window'\n\nconst { Provider, StaticJsonRpcProvider } = providers\ntype BaseProvider = providers.BaseProvider\n\ninterface NetworkProviderProps {\n  providerOverrides?: Providers\n  children?: ReactNode\n}\n\nconst getProviderFromConfig = (urlOrProviderOrProviderFunction: string | BaseProvider | BaseProviderFactory) => {\n  if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n    return urlOrProviderOrProviderFunction\n  }\n  if (typeof urlOrProviderOrProviderFunction === 'function') {\n    return urlOrProviderOrProviderFunction()\n  }\n  return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction)\n}\n\nexport const getProvidersFromConfig = (readOnlyUrls: NodeUrls) =>\n  fromEntries(\n    Object.entries(readOnlyUrls).map(([chainId, urlOrProviderOrProviderFunction]) => [\n      chainId,\n      getProviderFromConfig(urlOrProviderOrProviderFunction),\n    ])\n  )\n\nexport function ReadonlyNetworksProvider({ providerOverrides = {}, children }: NetworkProviderProps) {\n  const { readOnlyUrls = {}, pollingInterval, pollingIntervals } = useConfig()\n  const { isActive } = useWindow()\n  const [providers, setProviders] = useState<Providers>(() => ({\n    ...getProvidersFromConfig(readOnlyUrls),\n    ...providerOverrides,\n  }))\n  const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, {\n    ...fromEntries(\n      Object.keys({ ...readOnlyUrls, ...providerOverrides }).map((chainId) => [chainId, { nonStaticCalls: 0 }])\n    ),\n  })\n  const getPollingInterval = useCallback((chainId: number) => pollingIntervals?.[chainId] ?? pollingInterval, [\n    pollingInterval,\n    pollingIntervals,\n  ])\n\n  useEffect(() => {\n    setProviders({ ...getProvidersFromConfig(readOnlyUrls), ...providerOverrides })\n  }, Object.entries(readOnlyUrls).flat())\n\n  useEffect(() => {\n    for (const [chainId, { nonStaticCalls }] of Object.entries(networkStates)) {\n      const provider = providers[(chainId as unknown) as ChainId]\n      if (provider) {\n        provider.polling = isActive && nonStaticCalls > 0\n      }\n    }\n  }, [networkStates, isActive])\n\n  useEffect(() => {\n    for (const [chainId, provider] of Object.entries(providers)) {\n      provider.pollingInterval = getPollingInterval(Number(chainId))\n    }\n  }, [providers, getPollingInterval])\n\n  const networks = useMemo(\n    () => ({\n      providers,\n      updateNetworkState: dispatchNetworkState,\n    }),\n    [providers, dispatchNetworkState]\n  )\n\n  return <ReadonlyNetworksContext.Provider value={networks}>{children}</ReadonlyNetworksContext.Provider>\n}\n"]},"metadata":{},"sourceType":"module"}