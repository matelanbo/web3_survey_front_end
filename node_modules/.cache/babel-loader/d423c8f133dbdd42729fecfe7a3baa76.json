{"ast":null,"code":"import { decodeUint, fail, wordLength } from '../common';\nexport function decodeAggregate(calldata) {\n  // function aggregate(tuple(address target, bytes callData)[] calls) public returns (tuple(uint256 blockNumber, bytes returnData)[])\n  const errorMethodId = '0x08c379a0';\n\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall aggregate: call failed');\n  }\n\n  calldata = calldata.slice(2); // 'remove 0x prefix'\n\n  const getNumber = offset => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength));\n\n  const blockNumber = getNumber(0); // The array offset must be 0x40 - blockNumber + array offset\n\n  if (getNumber(1) !== 0x40) {\n    fail();\n  }\n\n  const arraySize = getNumber(2);\n  const calls = [];\n\n  for (let i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    const callOffset = 2 * getNumber(i + 3) + 3 * wordLength; // * 2 because 1 byte = 2 chars\n    // position of the call if we split calldata in chunks of 32 bytes\n\n    const pos = callOffset / wordLength; // returnData is encoded as its length and the data itself\n\n    const returnDataOffset = (pos + 1) * wordLength;\n    const returnDataLength = getNumber(pos);\n    const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength); // * 2 because 1 byte = 2 chars\n\n    calls.push('0x' + returnData);\n  }\n\n  return [blockNumber, calls];\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAT,EAAqBC,IAArB,EAA2BC,UAA3B,QAA6C,WAA7C;AAEA,OAAM,SAAUC,eAAV,CAA0BC,QAA1B,EAA0C;EAC9C;EACA,MAAMC,aAAa,GAAG,YAAtB;;EACA,IAAID,QAAQ,CAACE,UAAT,CAAoBD,aAApB,CAAJ,EAAwC;IACtC,MAAM,IAAIE,KAAJ,CAAU,kCAAV,CAAN;EACD;;EACDH,QAAQ,GAAGA,QAAQ,CAACI,KAAT,CAAe,CAAf,CAAX,CAN8C,CAMjB;;EAC7B,MAAMC,SAAS,GAAIC,MAAD,IAAoBV,UAAU,CAACI,QAAQ,CAACI,KAAT,CAAeE,MAAM,GAAGR,UAAxB,EAAoC,CAACQ,MAAM,GAAG,CAAV,IAAeR,UAAnD,CAAD,CAAhD;;EAEA,MAAMS,WAAW,GAAGF,SAAS,CAAC,CAAD,CAA7B,CAT8C,CAU9C;;EACA,IAAIA,SAAS,CAAC,CAAD,CAAT,KAAiB,IAArB,EAA2B;IACzBR,IAAI;EACL;;EACD,MAAMW,SAAS,GAAGH,SAAS,CAAC,CAAD,CAA3B;EACA,MAAMI,KAAK,GAAa,EAAxB;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAApB,EAA+BE,CAAC,EAAhC,EAAoC;IAClC;IACA,MAAMC,UAAU,GAAG,IAAIN,SAAS,CAACK,CAAC,GAAG,CAAL,CAAb,GAAuB,IAAIZ,UAA9C,CAFkC,CAEuB;IACzD;;IACA,MAAMc,GAAG,GAAGD,UAAU,GAAGb,UAAzB,CAJkC,CAKlC;;IACA,MAAMe,gBAAgB,GAAG,CAACD,GAAG,GAAG,CAAP,IAAYd,UAArC;IACA,MAAMgB,gBAAgB,GAAGT,SAAS,CAACO,GAAD,CAAlC;IACA,MAAMG,UAAU,GAAGf,QAAQ,CAACI,KAAT,CAAeS,gBAAf,EAAiCA,gBAAgB,GAAG,IAAIC,gBAAxD,CAAnB,CARkC,CAQ2D;;IAC7FL,KAAK,CAACO,IAAN,CAAW,OAAOD,UAAlB;EACD;;EACD,OAAO,CAACR,WAAD,EAAcE,KAAd,CAAP;AACD","names":["decodeUint","fail","wordLength","decodeAggregate","calldata","errorMethodId","startsWith","Error","slice","getNumber","offset","blockNumber","arraySize","calls","i","callOffset","pos","returnDataOffset","returnDataLength","returnData","push"],"sources":["/Users/qianyisheng/Desktop/web3/brownie_test/brownie_fund_me/front_end/node_modules/@usedapp/core/src/abi/multicall/decoder.ts"],"sourcesContent":["import { decodeUint, fail, wordLength } from '../common'\n\nexport function decodeAggregate(calldata: string): [number, string[]] {\n  // function aggregate(tuple(address target, bytes callData)[] calls) public returns (tuple(uint256 blockNumber, bytes returnData)[])\n  const errorMethodId = '0x08c379a0'\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall aggregate: call failed')\n  }\n  calldata = calldata.slice(2) // 'remove 0x prefix'\n  const getNumber = (offset: number) => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength))\n\n  const blockNumber = getNumber(0)\n  // The array offset must be 0x40 - blockNumber + array offset\n  if (getNumber(1) !== 0x40) {\n    fail()\n  }\n  const arraySize = getNumber(2)\n  const calls: string[] = []\n\n  for (let i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    const callOffset = 2 * getNumber(i + 3) + 3 * wordLength // * 2 because 1 byte = 2 chars\n    // position of the call if we split calldata in chunks of 32 bytes\n    const pos = callOffset / wordLength\n    // returnData is encoded as its length and the data itself\n    const returnDataOffset = (pos + 1) * wordLength\n    const returnDataLength = getNumber(pos)\n    const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength) // * 2 because 1 byte = 2 chars\n    calls.push('0x' + returnData)\n  }\n  return [blockNumber, calls]\n}\n"]},"metadata":{},"sourceType":"module"}