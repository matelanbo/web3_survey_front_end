{"ast":null,"code":"import { decodeUint, wordLength, fail } from '../common';\nexport function decodeTryAggregate(calldata) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  const errorMethodId = '0x08c379a0';\n\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall2 aggregate: call failed');\n  }\n\n  calldata = calldata.slice(2); // 'remove 0x prefix'\n\n  const getNumber = offset => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength)); // The array offset must be 0x20 - nothing is before the array\n\n\n  if (getNumber(0) !== 0x20) {\n    fail();\n  }\n\n  const arraySize = getNumber(1);\n  const calls = [];\n\n  for (let i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    const callOffset = 2 * getNumber(i + 2) + 2 * wordLength; // position of the call if we split calldata in chunks of 32 bytes\n\n    const pos = callOffset / wordLength; // returnData is encoded as a flag showing if the call was successful,\n    // data offset, which should be equal to 0x40, data length and the data itself\n\n    const successEncoded = getNumber(pos);\n\n    if (successEncoded !== 1 && successEncoded !== 0) {\n      fail();\n    }\n\n    const success = successEncoded === 1;\n\n    if (getNumber(pos + 1) !== 0x40) {\n      fail();\n    }\n\n    const returnDataOffset = (pos + 3) * wordLength;\n    const returnDataLength = getNumber(pos + 2);\n    const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength);\n    const call = [success, '0x' + returnData];\n    calls.push(call);\n  }\n\n  return [calls];\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAT,EAAqBC,UAArB,EAAiCC,IAAjC,QAA6C,WAA7C;AAEA,OAAM,SAAUC,kBAAV,CAA6BC,QAA7B,EAA6C;EACjD;EACA,MAAMC,aAAa,GAAG,YAAtB;;EACA,IAAID,QAAQ,CAACE,UAAT,CAAoBD,aAApB,CAAJ,EAAwC;IACtC,MAAM,IAAIE,KAAJ,CAAU,mCAAV,CAAN;EACD;;EACDH,QAAQ,GAAGA,QAAQ,CAACI,KAAT,CAAe,CAAf,CAAX,CANiD,CAMpB;;EAC7B,MAAMC,SAAS,GAAIC,MAAD,IAAoBV,UAAU,CAACI,QAAQ,CAACI,KAAT,CAAeE,MAAM,GAAGT,UAAxB,EAAoC,CAACS,MAAM,GAAG,CAAV,IAAeT,UAAnD,CAAD,CAAhD,CAPiD,CASjD;;;EACA,IAAIQ,SAAS,CAAC,CAAD,CAAT,KAAiB,IAArB,EAA2B;IACzBP,IAAI;EACL;;EACD,MAAMS,SAAS,GAAGF,SAAS,CAAC,CAAD,CAA3B;EACA,MAAMG,KAAK,GAAwB,EAAnC;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAApB,EAA+BE,CAAC,EAAhC,EAAoC;IAClC;IACA,MAAMC,UAAU,GAAG,IAAIL,SAAS,CAACI,CAAC,GAAG,CAAL,CAAb,GAAuB,IAAIZ,UAA9C,CAFkC,CAGlC;;IACA,MAAMc,GAAG,GAAGD,UAAU,GAAGb,UAAzB,CAJkC,CAKlC;IACA;;IACA,MAAMe,cAAc,GAAGP,SAAS,CAACM,GAAD,CAAhC;;IACA,IAAIC,cAAc,KAAK,CAAnB,IAAwBA,cAAc,KAAK,CAA/C,EAAkD;MAChDd,IAAI;IACL;;IACD,MAAMe,OAAO,GAAGD,cAAc,KAAK,CAAnC;;IACA,IAAIP,SAAS,CAACM,GAAG,GAAG,CAAP,CAAT,KAAuB,IAA3B,EAAiC;MAC/Bb,IAAI;IACL;;IACD,MAAMgB,gBAAgB,GAAG,CAACH,GAAG,GAAG,CAAP,IAAYd,UAArC;IACA,MAAMkB,gBAAgB,GAAGV,SAAS,CAACM,GAAG,GAAG,CAAP,CAAlC;IACA,MAAMK,UAAU,GAAGhB,QAAQ,CAACI,KAAT,CAAeU,gBAAf,EAAiCA,gBAAgB,GAAG,IAAIC,gBAAxD,CAAnB;IACA,MAAME,IAAI,GAAsB,CAACJ,OAAD,EAAU,OAAOG,UAAjB,CAAhC;IACAR,KAAK,CAACU,IAAN,CAAWD,IAAX;EACD;;EACD,OAAO,CAACT,KAAD,CAAP;AACD","names":["decodeUint","wordLength","fail","decodeTryAggregate","calldata","errorMethodId","startsWith","Error","slice","getNumber","offset","arraySize","calls","i","callOffset","pos","successEncoded","success","returnDataOffset","returnDataLength","returnData","call","push"],"sources":["/Users/qianyisheng/Desktop/web3/brownie_test/brownie_fund_me/front_end/node_modules/@usedapp/core/src/abi/multicall2/decoder.ts"],"sourcesContent":["import { decodeUint, wordLength, fail } from '../common'\n\nexport function decodeTryAggregate(calldata: string) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  const errorMethodId = '0x08c379a0'\n  if (calldata.startsWith(errorMethodId)) {\n    throw new Error('Multicall2 aggregate: call failed')\n  }\n  calldata = calldata.slice(2) // 'remove 0x prefix'\n  const getNumber = (offset: number) => decodeUint(calldata.slice(offset * wordLength, (offset + 1) * wordLength))\n\n  // The array offset must be 0x20 - nothing is before the array\n  if (getNumber(0) !== 0x20) {\n    fail()\n  }\n  const arraySize = getNumber(1)\n  const calls: [boolean, string][] = []\n\n  for (let i = 0; i < arraySize; i++) {\n    // offset of the call number i\n    const callOffset = 2 * getNumber(i + 2) + 2 * wordLength\n    // position of the call if we split calldata in chunks of 32 bytes\n    const pos = callOffset / wordLength\n    // returnData is encoded as a flag showing if the call was successful,\n    // data offset, which should be equal to 0x40, data length and the data itself\n    const successEncoded = getNumber(pos)\n    if (successEncoded !== 1 && successEncoded !== 0) {\n      fail()\n    }\n    const success = successEncoded === 1\n    if (getNumber(pos + 1) !== 0x40) {\n      fail()\n    }\n    const returnDataOffset = (pos + 3) * wordLength\n    const returnDataLength = getNumber(pos + 2)\n    const returnData = calldata.slice(returnDataOffset, returnDataOffset + 2 * returnDataLength)\n    const call: [boolean, string] = [success, '0x' + returnData]\n    calls.push(call)\n  }\n  return [calls]\n}\n"]},"metadata":{},"sourceType":"module"}