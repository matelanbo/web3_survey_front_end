{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer, useState } from 'react';\nimport { NetworkContext } from './context';\nimport { defaultNetworkState, networkReducer } from './reducer';\nimport { providers } from 'ethers';\nimport { subscribeToProviderEvents, getInjectedProvider } from '../../../helpers';\nimport { useLocalStorage, useConfig } from '../../../hooks';\nimport detectEthereumProvider from '@metamask/detect-provider';\nconst Provider = providers.Provider;\nconst Web3Provider = providers.Web3Provider;\n\nasync function tryToGetAccount(provider) {\n  try {\n    return await provider.getSigner().getAddress();\n  } catch (err) {\n    if (err.code === 'UNSUPPORTED_OPERATION') {\n      // readonly provider\n      return undefined;\n    }\n\n    throw err;\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\n\nexport function NetworkProvider(_ref) {\n  let {\n    children,\n    providerOverride\n  } = _ref;\n  const {\n    autoConnect,\n    pollingInterval,\n    noMetamaskDeactivate,\n    pollingIntervals\n  } = useConfig();\n  const [network, dispatch] = useReducer(networkReducer, defaultNetworkState);\n  const [onUnsubscribe, setOnUnsubscribe] = useState(() => () => undefined);\n  const [shouldConnectMetamask, setShouldConnectMetamask] = useLocalStorage('shouldConnectMetamask');\n  const [isLoading, setLoading] = useState(false);\n  const getPollingInterval = useCallback(chainId => {\n    var _a;\n\n    return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval;\n  }, [pollingInterval, pollingIntervals]);\n  const activateBrowserWallet = useCallback(async () => {\n    setLoading(true);\n    const injectedProvider = await getInjectedProvider(getPollingInterval);\n\n    if (!injectedProvider) {\n      reportError(new Error('No injected provider available'));\n      setLoading(false);\n      console.error('No injected provider available'); // we do not want to crash the app when there is no metamask\n\n      return;\n    }\n\n    try {\n      await injectedProvider.send('eth_requestAccounts', []);\n      setShouldConnectMetamask(true);\n    } catch (err) {\n      reportError(err);\n      setShouldConnectMetamask(false);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n\n    return activate(injectedProvider);\n  }, []);\n  useEffect(() => {\n    if (providerOverride) {\n      void activate(providerOverride);\n    }\n  }, [providerOverride]);\n  const update = useCallback(newNetwork => {\n    dispatch({\n      type: 'UPDATE_NETWORK',\n      network: newNetwork\n    });\n  }, [network]);\n  const reportError = useCallback(error => {\n    console.error(error);\n    dispatch({\n      type: 'ADD_ERROR',\n      error\n    });\n  }, []);\n  const deactivate = useCallback(() => {\n    setShouldConnectMetamask(false);\n    update({\n      accounts: []\n    });\n  }, []);\n  const onDisconnect = useCallback(provider => error => {\n    const isMetaMask = provider.provider.isMetaMask;\n\n    if (!noMetamaskDeactivate || !isMetaMask) {\n      reportError(error);\n      deactivate();\n    }\n  }, []);\n  useEffect(() => {\n    setTimeout(async () => {\n      var _a, _b, _c;\n\n      try {\n        if (shouldConnectMetamask && autoConnect && !providerOverride) {\n          await detectEthereumProvider(); // If window.ethereum._state.accounts is non null but has no items,\n          // it probably means that the user has disconnected Metamask manually.\n\n          if (shouldConnectMetamask && ((_c = (_b = (_a = window.ethereum) === null || _a === void 0 ? void 0 : _a._state) === null || _b === void 0 ? void 0 : _b.accounts) === null || _c === void 0 ? void 0 : _c.length) === 0) {\n            return;\n          }\n\n          await activateBrowserWallet();\n        }\n      } catch (err) {\n        console.warn(err);\n      }\n    });\n  }, [shouldConnectMetamask, autoConnect, providerOverride]);\n  const activate = useCallback(async provider => {\n    var _a;\n\n    const wrappedProvider = Provider.isProvider(provider) ? provider : new Web3Provider(provider);\n\n    try {\n      setLoading(true);\n      const account = await tryToGetAccount(wrappedProvider);\n      const chainId = (_a = await wrappedProvider.getNetwork()) === null || _a === void 0 ? void 0 : _a.chainId;\n      onUnsubscribe();\n      const clearSubscriptions = subscribeToProviderEvents(wrappedProvider.provider, update, onDisconnect(wrappedProvider), chainId => {\n        wrappedProvider.pollingInterval = getPollingInterval(chainId);\n      });\n      setOnUnsubscribe(() => clearSubscriptions);\n      update({\n        provider: wrappedProvider,\n        chainId,\n        accounts: account ? [account] : []\n      });\n    } catch (err) {\n      reportError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [onUnsubscribe]);\n  return _jsx(NetworkContext.Provider, {\n    value: {\n      network,\n      update,\n      activate,\n      deactivate,\n      reportError,\n      activateBrowserWallet,\n      isLoading\n    },\n    children: children\n  });\n}","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useReducer","useState","NetworkContext","defaultNetworkState","networkReducer","providers","subscribeToProviderEvents","getInjectedProvider","useLocalStorage","useConfig","detectEthereumProvider","Provider","Web3Provider","tryToGetAccount","provider","getSigner","getAddress","err","code","undefined","NetworkProvider","children","providerOverride","autoConnect","pollingInterval","noMetamaskDeactivate","pollingIntervals","network","dispatch","onUnsubscribe","setOnUnsubscribe","shouldConnectMetamask","setShouldConnectMetamask","isLoading","setLoading","getPollingInterval","chainId","_a","activateBrowserWallet","injectedProvider","reportError","Error","console","error","send","activate","update","newNetwork","type","deactivate","accounts","onDisconnect","isMetaMask","setTimeout","window","ethereum","_state","_b","_c","length","warn","wrappedProvider","isProvider","account","getNetwork","clearSubscriptions","_jsx","value"],"sources":["/Users/qianyisheng/Desktop/web3/brownie_test/web3_survey/front_end/node_modules/@usedapp/core/src/providers/network/network/provider.tsx"],"sourcesContent":["import { ReactNode, useCallback, useEffect, useReducer, useState } from 'react'\nimport { NetworkContext } from './context'\nimport { defaultNetworkState, networkReducer } from './reducer'\nimport { Network } from './model'\nimport { providers } from 'ethers'\nimport { subscribeToProviderEvents, getInjectedProvider } from '../../../helpers'\nimport { useLocalStorage, useConfig } from '../../../hooks'\nimport detectEthereumProvider from '@metamask/detect-provider'\n\ntype JsonRpcProvider = providers.JsonRpcProvider\ntype ExternalProvider = providers.ExternalProvider\nconst Provider = providers.Provider\nconst Web3Provider = providers.Web3Provider\n\ninterface NetworkProviderProps {\n  children: ReactNode\n  providerOverride?: JsonRpcProvider\n}\n\nasync function tryToGetAccount(provider: JsonRpcProvider) {\n  try {\n    return await provider.getSigner().getAddress()\n  } catch (err: any) {\n    if (err.code === 'UNSUPPORTED_OPERATION') {\n      // readonly provider\n      return undefined\n    }\n    throw err\n  }\n}\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function NetworkProvider({ children, providerOverride }: NetworkProviderProps) {\n  const { autoConnect, pollingInterval, noMetamaskDeactivate, pollingIntervals } = useConfig()\n\n  const [network, dispatch] = useReducer(networkReducer, defaultNetworkState)\n  const [onUnsubscribe, setOnUnsubscribe] = useState<() => void>(() => () => undefined)\n  const [shouldConnectMetamask, setShouldConnectMetamask] = useLocalStorage('shouldConnectMetamask')\n  const [isLoading, setLoading] = useState(false)\n  const getPollingInterval = useCallback((chainId: number) => pollingIntervals?.[chainId] ?? pollingInterval, [\n    pollingInterval,\n    pollingIntervals,\n  ])\n\n  const activateBrowserWallet = useCallback(async () => {\n    setLoading(true)\n    const injectedProvider = await getInjectedProvider(getPollingInterval)\n\n    if (!injectedProvider) {\n      reportError(new Error('No injected provider available'))\n      setLoading(false)\n      console.error('No injected provider available') // we do not want to crash the app when there is no metamask\n      return\n    }\n    try {\n      await injectedProvider.send('eth_requestAccounts', [])\n      setShouldConnectMetamask(true)\n    } catch (err: any) {\n      reportError(err)\n      setShouldConnectMetamask(false)\n      throw err\n    } finally {\n      setLoading(false)\n    }\n    return activate(injectedProvider)\n  }, [])\n\n  useEffect(() => {\n    if (providerOverride) {\n      void activate(providerOverride)\n    }\n  }, [providerOverride])\n  const update = useCallback(\n    (newNetwork: Partial<Network>) => {\n      dispatch({ type: 'UPDATE_NETWORK', network: newNetwork })\n    },\n    [network]\n  )\n\n  const reportError = useCallback((error: Error) => {\n    console.error(error)\n    dispatch({ type: 'ADD_ERROR', error })\n  }, [])\n\n  const deactivate = useCallback(() => {\n    setShouldConnectMetamask(false)\n    update({\n      accounts: [],\n    })\n  }, [])\n\n  const onDisconnect = useCallback(\n    (provider: JsonRpcProvider) => (error: any) => {\n      const isMetaMask = (provider as any).provider.isMetaMask\n      if (!noMetamaskDeactivate || !isMetaMask) {\n        reportError(error)\n        deactivate()\n      }\n    },\n    []\n  )\n\n  useEffect(() => {\n    setTimeout(async () => {\n      try {\n        if (shouldConnectMetamask && autoConnect && !providerOverride) {\n          await detectEthereumProvider()\n\n          // If window.ethereum._state.accounts is non null but has no items,\n          // it probably means that the user has disconnected Metamask manually.\n          if (shouldConnectMetamask && (window.ethereum as any)?._state?.accounts?.length === 0) {\n            return\n          }\n\n          await activateBrowserWallet()\n        }\n      } catch (err) {\n        console.warn(err)\n      }\n    })\n  }, [shouldConnectMetamask, autoConnect, providerOverride])\n\n  const activate = useCallback(\n    async (provider: JsonRpcProvider | ExternalProvider) => {\n      const wrappedProvider = Provider.isProvider(provider) ? provider : new Web3Provider(provider)\n      try {\n        setLoading(true)\n        const account = await tryToGetAccount(wrappedProvider)\n        const chainId = (await wrappedProvider.getNetwork())?.chainId\n        onUnsubscribe()\n        const clearSubscriptions = subscribeToProviderEvents(\n          (wrappedProvider as any).provider,\n          update,\n          onDisconnect(wrappedProvider),\n          (chainId) => {\n            wrappedProvider.pollingInterval = getPollingInterval(chainId)\n          }\n        )\n        setOnUnsubscribe(() => clearSubscriptions)\n        update({\n          provider: wrappedProvider,\n          chainId,\n          accounts: account ? [account] : [],\n        })\n      } catch (err: any) {\n        reportError(err)\n        throw err\n      } finally {\n        setLoading(false)\n      }\n    },\n    [onUnsubscribe]\n  )\n  return (\n    <NetworkContext.Provider\n      value={{ network, update, activate, deactivate, reportError, activateBrowserWallet, isLoading }}\n      children={children}\n    />\n  )\n}\n"]},"metadata":{},"sourceType":"module"}