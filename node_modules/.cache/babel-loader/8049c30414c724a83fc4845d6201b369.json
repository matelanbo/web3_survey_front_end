{"ast":null,"code":"import { useMemo } from 'react';\nimport { useChainCalls } from './useChainCalls';\nimport { useChainId } from './useChainId';\n\nfunction warnOnInvalidContractCall(call) {\n  console.warn(`Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`);\n}\n\nfunction encodeCallData(call, chainId) {\n  if (!call) {\n    return undefined;\n  }\n\n  if (!call.address || !call.method) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n\n  try {\n    return {\n      address: call.address,\n      data: call.abi.encodeFunctionData(call.method, call.args),\n      chainId\n    };\n  } catch (_a) {\n    warnOnInvalidContractCall(call);\n    return undefined;\n  }\n}\n/**\n * Makes a call to a specific contract and returns the value. The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useChainCall} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param call a single call to a contract, also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCall} instead of this method as it is deprecated.\n * @returns the result of a call or undefined if call didn't return yet.\n */\n\n\nexport function useContractCall(call) {\n  let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useContractCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific contracts and returns values. The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useChainCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls , also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCalls} instead of this method as it is deprecated.\n * @returns array of results. Undefined if call didn't return yet.\n */\n\nexport function useContractCalls(calls) {\n  let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const chainId = useChainId({\n    queryParams\n  });\n  const rawCalls = useMemo(() => calls.map(call => chainId !== undefined ? encodeCallData(call, chainId) : undefined), [JSON.stringify(calls.map(call => {\n    var _a;\n\n    return call && {\n      address: (_a = call.address) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n      method: call.method,\n      args: call.args\n    };\n  })), chainId]);\n  const results = useChainCalls(rawCalls);\n  return useMemo(() => results.map((result, idx) => {\n    const call = calls[idx];\n\n    if (result === '0x') {\n      warnOnInvalidContractCall(call);\n      return undefined;\n    }\n\n    return call && result ? call.abi.decodeFunctionResult(call.method, result) : undefined;\n  }), [JSON.stringify(results)]);\n}","map":{"version":3,"mappings":"AACA,SAASA,OAAT,QAAwB,OAAxB;AAKA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,UAAT,QAA2B,cAA3B;;AAEA,SAASC,yBAAT,CAAmCC,IAAnC,EAA6D;EAC3DC,OAAO,CAACC,IAAR,CACE,kCAAkCF,IAAI,IAAIA,IAAI,CAACG,OAAO,WAAWH,IAAI,IAAIA,IAAI,CAACI,MAAM,SAASJ,IAAI,IAAIA,IAAI,CAACK,IAAI,EADhH;AAGD;;AAED,SAASC,cAAT,CAAwBN,IAAxB,EAAoDO,OAApD,EAAoE;EAClE,IAAI,CAACP,IAAL,EAAW;IACT,OAAOQ,SAAP;EACD;;EACD,IAAI,CAACR,IAAI,CAACG,OAAN,IAAiB,CAACH,IAAI,CAACI,MAA3B,EAAmC;IACjCL,yBAAyB,CAACC,IAAD,CAAzB;IACA,OAAOQ,SAAP;EACD;;EACD,IAAI;IACF,OAAO;MAAEL,OAAO,EAAEH,IAAI,CAACG,OAAhB;MAAyBM,IAAI,EAAET,IAAI,CAACU,GAAL,CAASC,kBAAT,CAA4BX,IAAI,CAACI,MAAjC,EAAyCJ,IAAI,CAACK,IAA9C,CAA/B;MAAoFE;IAApF,CAAP;EACD,CAFD,CAEE,WAAM;IACNR,yBAAyB,CAACC,IAAD,CAAzB;IACA,OAAOQ,SAAP;EACD;AACF;AAaD;;;;;;;;;;AAQA,OAAM,SAAUI,eAAV,CAA0BZ,IAA1B,EAAmF;EAAA,IAA7Ba,WAA6B,uEAAF,EAAE;EACvF,OAAOC,gBAAgB,CAAC,CAACd,IAAD,CAAD,EAASa,WAAT,CAAhB,CAAsC,CAAtC,CAAP;AACD;AAED;;;;;;;;;AAQA,OAAM,SAAUC,gBAAV,CACJC,KADI,EAEyB;EAAA,IAA7BF,WAA6B,uEAAF,EAAE;EAE7B,MAAMN,OAAO,GAAGT,UAAU,CAAC;IAAEe;EAAF,CAAD,CAA1B;EAEA,MAAMG,QAAQ,GAAGpB,OAAO,CACtB,MAAMmB,KAAK,CAACE,GAAN,CAAWjB,IAAD,IAAWO,OAAO,KAAKC,SAAZ,GAAwBF,cAAc,CAACN,IAAD,EAAOO,OAAP,CAAtC,GAAwDC,SAA7E,CADgB,EAEtB,CACEU,IAAI,CAACC,SAAL,CACEJ,KAAK,CAACE,GAAN,CAAWjB,IAAD,IAAS;IAAA;;IAAC,WAAI,IAAI;MAAEG,OAAO,EAAE,UAAI,CAACA,OAAL,MAAY,IAAZ,IAAYiB,aAAZ,GAAY,MAAZ,GAAYA,GAAEC,WAAF,EAAvB;MAAwCjB,MAAM,EAAEJ,IAAI,CAACI,MAArD;MAA6DC,IAAI,EAAEL,IAAI,CAACK;IAAxE,CAAR;EAAsF,CAA1G,CADF,CADF,EAIEE,OAJF,CAFsB,CAAxB;EAUA,MAAMe,OAAO,GAAGzB,aAAa,CAACmB,QAAD,CAA7B;EAEA,OAAOpB,OAAO,CACZ,MACE0B,OAAO,CAACL,GAAR,CAAY,CAACM,MAAD,EAASC,GAAT,KAAgB;IAC1B,MAAMxB,IAAI,GAAGe,KAAK,CAACS,GAAD,CAAlB;;IACA,IAAID,MAAM,KAAK,IAAf,EAAqB;MACnBxB,yBAAyB,CAACC,IAAD,CAAzB;MACA,OAAOQ,SAAP;IACD;;IACD,OAAOR,IAAI,IAAIuB,MAAR,GAAkBvB,IAAI,CAACU,GAAL,CAASe,oBAAT,CAA8BzB,IAAI,CAACI,MAAnC,EAA2CmB,MAA3C,CAAlB,GAAiFf,SAAxF;EACD,CAPD,CAFU,EAUZ,CAACU,IAAI,CAACC,SAAL,CAAeG,OAAf,CAAD,CAVY,CAAd;AAYD","names":["useMemo","useChainCalls","useChainId","warnOnInvalidContractCall","call","console","warn","address","method","args","encodeCallData","chainId","undefined","data","abi","encodeFunctionData","useContractCall","queryParams","useContractCalls","calls","rawCalls","map","JSON","stringify","_a","toLowerCase","results","result","idx","decodeFunctionResult"],"sources":["/Users/qianyisheng/Desktop/web3/brownie_test/web3_survey/front_end/node_modules/@usedapp/core/src/hooks/useContractCall.ts"],"sourcesContent":["import { utils } from 'ethers'\nimport { useMemo } from 'react'\nimport { ChainId } from '../constants'\nimport { QueryParams } from '../constants/type/QueryParams'\nimport { Falsy } from '../model/types'\nimport { RawCall } from '../providers'\nimport { useChainCalls } from './useChainCalls'\nimport { useChainId } from './useChainId'\n\nfunction warnOnInvalidContractCall(call: ContractCall | Falsy) {\n  console.warn(\n    `Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`\n  )\n}\n\nfunction encodeCallData(call: ContractCall | Falsy, chainId: ChainId): RawCall | Falsy {\n  if (!call) {\n    return undefined\n  }\n  if (!call.address || !call.method) {\n    warnOnInvalidContractCall(call)\n    return undefined\n  }\n  try {\n    return { address: call.address, data: call.abi.encodeFunctionData(call.method, call.args), chainId }\n  } catch {\n    warnOnInvalidContractCall(call)\n    return undefined\n  }\n}\n\n/**\n * @public\n * @deprecated Use {@link useCall} instead.\n */\nexport interface ContractCall {\n  abi: utils.Interface\n  address: string\n  method: string\n  args: any[]\n}\n\n/**\n * Makes a call to a specific contract and returns the value. The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useChainCall} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param call a single call to a contract, also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCall} instead of this method as it is deprecated.\n * @returns the result of a call or undefined if call didn't return yet.\n */\nexport function useContractCall(call: ContractCall | Falsy, queryParams: QueryParams = {}): any[] | undefined {\n  return useContractCalls([call], queryParams)[0]\n}\n\n/**\n * Makes calls to specific contracts and returns values. The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useChainCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls , also see {@link ContractCall}.\n * @deprecated It is recommended to use {@link useCalls} instead of this method as it is deprecated.\n * @returns array of results. Undefined if call didn't return yet.\n */\nexport function useContractCalls(\n  calls: (ContractCall | Falsy)[],\n  queryParams: QueryParams = {}\n): (any[] | undefined)[] {\n  const chainId = useChainId({ queryParams })\n\n  const rawCalls = useMemo(\n    () => calls.map((call) => (chainId !== undefined ? encodeCallData(call, chainId) : undefined)),\n    [\n      JSON.stringify(\n        calls.map((call) => call && { address: call.address?.toLowerCase(), method: call.method, args: call.args })\n      ),\n      chainId,\n    ]\n  )\n\n  const results = useChainCalls(rawCalls)\n\n  return useMemo(\n    () =>\n      results.map((result, idx) => {\n        const call = calls[idx]\n        if (result === '0x') {\n          warnOnInvalidContractCall(call)\n          return undefined\n        }\n        return call && result ? (call.abi.decodeFunctionResult(call.method, result) as any[]) : undefined\n      }),\n    [JSON.stringify(results)]\n  )\n}\n"]},"metadata":{},"sourceType":"module"}