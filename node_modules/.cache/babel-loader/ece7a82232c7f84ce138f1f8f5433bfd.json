{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { useConfig, useNetwork } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory } from '../common';\nimport { getCallsForUpdate, getUniqueActiveCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\nimport { useWindow } from '../../window/context';\nimport { useUpdateNetworksState } from '../../network/readonlyNetworks/context';\n\nfunction composeChainState(networks, state, multicallAddresses) {\n  return fromEntries(Object.keys(networks).map(chainId => [Number(chainId), {\n    value: state[Number(chainId)],\n    multicallAddress: multicallAddresses[Number(chainId)]\n  }]));\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nconst stripCall = _a => {\n  var {\n    isStatic,\n    lastUpdatedBlockNumber\n  } = _a,\n      strippedCall = __rest(_a, [\"isStatic\", \"lastUpdatedBlockNumber\"]);\n\n  return strippedCall;\n};\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\n\nexport function MultiChainStateProvider(_ref) {\n  let {\n    children,\n    multicallAddresses\n  } = _ref;\n  const {\n    multicallVersion,\n    fastMulticallEncoding\n  } = useConfig();\n  const networks = useReadonlyNetworks();\n  const blockNumbers = useBlockNumbers();\n  const {\n    reportError\n  } = useNetwork();\n  const {\n    isActive\n  } = useWindow();\n  const [calls, dispatchCalls] = useReducer(callsReducer, []);\n  const [state, dispatchState] = useReducer(chainStateReducer, {});\n  const updateNetworks = useUpdateNetworksState();\n  const multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding !== null && fastMulticallEncoding !== void 0 ? fastMulticallEncoding : false);\n  const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n  const uniqueCalls = useMemo(() => getUniqueActiveCalls(debouncedCalls), [debouncedCalls]); // used for deep equality in hook dependencies\n\n  const uniqueCallsJSON = JSON.stringify(debouncedCalls.map(stripCall));\n  const chainId = useChainId();\n  useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n\n  function multicallForChain(chainId, provider) {\n    if (!isActive) {\n      return;\n    }\n\n    const blockNumber = blockNumbers[chainId];\n    const multicallAddress = multicallAddresses[chainId];\n\n    if (!provider || !blockNumber) {\n      return;\n    }\n\n    if (!multicallAddress) {\n      reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n      return;\n    }\n\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return;\n    }\n\n    const updatedCalls = getCallsForUpdate(debouncedCalls, {\n      chainId,\n      blockNumber\n    });\n    const callsOnThisChain = getUniqueActiveCalls(updatedCalls);\n    updateNetworks({\n      type: 'UPDATE_NON_STATIC_CALLS_COUNT',\n      chainId,\n      count: calls.filter(call => !call.isStatic && call.chainId === chainId).length\n    });\n    performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n    dispatchCalls({\n      type: 'UPDATE_CALLS',\n      calls,\n      updatedCalls,\n      blockNumber,\n      chainId\n    });\n  }\n\n  useEffect(() => {\n    var _a, _b;\n\n    for (const [_chainId, provider] of Object.entries(networks)) {\n      const chainId = Number(_chainId); // chainId is in provider is not the same as the chainId in the state wait for chainId to catch up\n\n      if (chainId === ((_a = provider.network) === null || _a === void 0 ? void 0 : _a.chainId) || chainId === ((_b = provider._network) === null || _b === void 0 ? void 0 : _b.chainId)) {\n        multicallForChain(chainId, provider);\n      }\n    }\n  }, [networks, multicallAddresses, uniqueCallsJSON, blockNumbers]);\n  const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [state, multicallAddresses, networks]);\n  const provided = {\n    chains,\n    dispatchCalls\n  };\n  return _jsx(MultiChainStatesContext.Provider, {\n    value: provided,\n    children: children\n  });\n}","map":{"version":3,"mappings":"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","names":["useEffect","useMemo","useReducer","useDebouncePair","useBlockNumbers","MultiChainStatesContext","useConfig","useNetwork","useReadonlyNetworks","fromEntries","performMulticall","callsReducer","chainStateReducer","multicall1Factory","multicall2Factory","getCallsForUpdate","getUniqueActiveCalls","useDevtoolsReporting","useChainId","useWindow","useUpdateNetworksState","composeChainState","networks","state","multicallAddresses","Object","keys","map","chainId","Number","value","multicallAddress","stripCall","_a","isStatic","lastUpdatedBlockNumber","strippedCall","MultiChainStateProvider","children","multicallVersion","fastMulticallEncoding","blockNumbers","reportError","isActive","calls","dispatchCalls","dispatchState","updateNetworks","multicall","debouncedCalls","debouncedNetworks","uniqueCalls","uniqueCallsJSON","JSON","stringify","undefined","multicallForChain","provider","blockNumber","Error","updatedCalls","callsOnThisChain","type","count","filter","call","length","_chainId","entries","network","_network","_b","chains","provided","_jsx","Provider"],"sources":["/Users/qianyisheng/Desktop/web3/brownie_test/web3_survey/front_end/node_modules/@usedapp/core/src/providers/chainState/multiChainStates/provider.tsx"],"sourcesContent":["import { ReactNode, useEffect, useMemo, useReducer } from 'react'\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks'\nimport { MultiChainStatesContext } from './context'\nimport { ChainId, State, useConfig, useNetwork } from '../../..'\nimport { useReadonlyNetworks } from '../../network'\nimport { fromEntries } from '../../../helpers/fromEntries'\nimport { performMulticall } from '../common/performMulticall'\nimport { Providers } from '../../network/readonlyNetworks/model'\nimport { providers } from 'ethers'\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory, RawCall } from '../common'\nimport { getCallsForUpdate, getUniqueActiveCalls } from '../../../helpers'\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting'\nimport { useChainId } from '../../../hooks/useChainId'\nimport { useWindow } from '../../window/context'\nimport { useUpdateNetworksState } from '../../network/readonlyNetworks/context'\n\ninterface Props {\n  children: ReactNode\n  multicallAddresses: {\n    [chainId: number]: string\n  }\n}\n\nfunction composeChainState(networks: Providers, state: State, multicallAddresses: Props['multicallAddresses']) {\n  return fromEntries(\n    Object.keys(networks).map((chainId) => [\n      Number(chainId),\n      {\n        value: state[Number(chainId)],\n        multicallAddress: multicallAddresses[Number(chainId)],\n      },\n    ])\n  )\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stripCall = ({ isStatic, lastUpdatedBlockNumber, ...strippedCall }: RawCall) => strippedCall\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function MultiChainStateProvider({ children, multicallAddresses }: Props) {\n  const { multicallVersion, fastMulticallEncoding } = useConfig()\n  const networks = useReadonlyNetworks()\n  const blockNumbers = useBlockNumbers()\n  const { reportError } = useNetwork()\n  const { isActive } = useWindow()\n\n  const [calls, dispatchCalls] = useReducer(callsReducer, [])\n  const [state, dispatchState] = useReducer(chainStateReducer, {})\n  const updateNetworks = useUpdateNetworksState()\n\n  const multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding ?? false)\n\n  const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50)\n  const uniqueCalls = useMemo(() => getUniqueActiveCalls(debouncedCalls), [debouncedCalls])\n\n  // used for deep equality in hook dependencies\n  const uniqueCallsJSON = JSON.stringify(debouncedCalls.map(stripCall))\n\n  const chainId = useChainId()\n  useDevtoolsReporting(\n    uniqueCallsJSON,\n    uniqueCalls,\n    chainId !== undefined ? blockNumbers[chainId as ChainId] : undefined,\n    multicallAddresses\n  )\n\n  function multicallForChain(chainId: ChainId, provider: providers.BaseProvider) {\n    if (!isActive) {\n      return\n    }\n    const blockNumber = blockNumbers[chainId]\n    const multicallAddress = multicallAddresses[chainId]\n\n    if (!provider || !blockNumber) {\n      return\n    }\n    if (!multicallAddress) {\n      reportError(new Error(`Missing multicall address for chain id ${chainId}`))\n      return\n    }\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return\n    }\n\n    const updatedCalls = getCallsForUpdate(debouncedCalls, { chainId, blockNumber })\n    const callsOnThisChain = getUniqueActiveCalls(updatedCalls)\n\n    updateNetworks({\n      type: 'UPDATE_NON_STATIC_CALLS_COUNT',\n      chainId,\n      count: calls.filter((call) => !call.isStatic && call.chainId === chainId).length,\n    })\n\n    performMulticall(\n      provider,\n      multicall,\n      multicallAddress,\n      blockNumber,\n      callsOnThisChain,\n      dispatchState,\n      chainId,\n      reportError\n    )\n    dispatchCalls({ type: 'UPDATE_CALLS', calls, updatedCalls, blockNumber, chainId })\n  }\n\n  useEffect(() => {\n    for (const [_chainId, provider] of Object.entries(networks)) {\n      const chainId = Number(_chainId)\n      // chainId is in provider is not the same as the chainId in the state wait for chainId to catch up\n      if (chainId === provider.network?.chainId || chainId === provider._network?.chainId) {\n        multicallForChain(chainId, provider)\n      }\n    }\n  }, [networks, multicallAddresses, uniqueCallsJSON, blockNumbers])\n\n  const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [\n    state,\n    multicallAddresses,\n    networks,\n  ])\n\n  const provided = { chains, dispatchCalls }\n\n  return <MultiChainStatesContext.Provider value={provided} children={children} />\n}\n"]},"metadata":{},"sourceType":"module"}