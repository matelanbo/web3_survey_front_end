{"ast":null,"code":"import { useConfig } from './useConfig';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction';\nimport { useReadonlyNetworks } from '../providers';\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function connectContractToSigner(contract, options, librarySigner) {\n  if (contract.signer) {\n    return contract;\n  }\n\n  if (options && 'signer' in options) {\n    return contract.connect(options.signer);\n  }\n\n  if (librarySigner) {\n    return contract.connect(librarySigner);\n  }\n\n  throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\n\nexport function useContractFunction(contract, functionName, options) {\n  var _a, _b, _c;\n\n  const {\n    library,\n    chainId\n  } = useEthers();\n  const transactionChainId = options && 'chainId' in options && (options === null || options === void 0 ? void 0 : options.chainId) || chainId;\n  const {\n    promiseTransaction,\n    state,\n    resetState\n  } = usePromiseTransaction(transactionChainId, options);\n  const [events, setEvents] = useState(undefined);\n  const config = useConfig();\n  const gasLimitBufferPercentage = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.gasLimitBufferPercentage) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.bufferGasLimitPercentage) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.gasLimitBufferPercentage) !== null && _c !== void 0 ? _c : 0;\n  const providers = useReadonlyNetworks();\n  const provider = transactionChainId && providers[transactionChainId];\n  const send = useCallback(async function () {\n    var _a, _b;\n\n    if (contract) {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      const hasOpts = args.length > ((_b = (_a = contract.interface) === null || _a === void 0 ? void 0 : _a.getFunction(functionName).inputs.length) !== null && _b !== void 0 ? _b : 0);\n      const signer = getSignerFromOptions(provider, options, library);\n      const contractWithSigner = connectContractToSigner(contract, options, signer);\n      const opts = hasOpts ? args[args.length - 1] : undefined;\n      const gasLimit = await estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage);\n      const modifiedOpts = Object.assign(Object.assign({}, opts), {\n        gasLimit\n      });\n      const modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args;\n      modifiedArgs.push(modifiedOpts);\n      const receipt = await promiseTransaction(contractWithSigner[functionName](...modifiedArgs));\n\n      if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n        const events = receipt.logs.reduce((accumulatedLogs, log) => {\n          try {\n            return log.address.toLowerCase() === contract.address.toLowerCase() ? [...accumulatedLogs, contract.interface.parseLog(log)] : accumulatedLogs;\n          } catch (_err) {\n            return accumulatedLogs;\n          }\n        }, []);\n        setEvents(events);\n      }\n\n      return receipt;\n    }\n  }, [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]);\n  return {\n    send,\n    state,\n    events,\n    resetState\n  };\n}","map":{"version":3,"mappings":"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","names":["useConfig","useCallback","useState","useEthers","estimateContractFunctionGasLimit","usePromiseTransaction","useReadonlyNetworks","getSignerFromOptions","connectContractToSigner","contract","options","librarySigner","signer","connect","TypeError","useContractFunction","functionName","library","chainId","transactionChainId","promiseTransaction","state","resetState","events","setEvents","undefined","config","gasLimitBufferPercentage","_a","bufferGasLimitPercentage","_b","_c","providers","provider","send","args","hasOpts","length","interface","getFunction","inputs","contractWithSigner","opts","gasLimit","modifiedOpts","modifiedArgs","slice","push","receipt","logs","reduce","accumulatedLogs","log","address","toLowerCase","parseLog","_err"],"sources":["/Users/qianyisheng/Desktop/web3/brownie_test/brownie_fund_me/front_end/node_modules/@usedapp/core/src/hooks/useContractFunction.ts"],"sourcesContent":["import { TransactionOptions } from '../model/TransactionOptions'\nimport { useConfig } from './useConfig'\nimport { Contract, Signer, providers } from 'ethers'\nimport { useCallback, useState } from 'react'\nimport { useEthers } from './useEthers'\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction'\nimport { LogDescription } from 'ethers/lib/utils'\nimport { ContractFunctionNames, Falsy, Params, TypedContract } from '../model/types'\nimport { TransactionReceipt } from '@ethersproject/abstract-provider'\nimport { useReadonlyNetworks } from '../providers'\nimport { ChainId } from '../constants'\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions'\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract: Contract, options?: TransactionOptions, librarySigner?: Signer) {\n  if (contract.signer) {\n    return contract\n  }\n\n  if (options && 'signer' in options) {\n    return contract.connect(options.signer)\n  }\n\n  if (librarySigner) {\n    return contract.connect(librarySigner)\n  }\n\n  throw new TypeError('No signer available in contract, options or library')\n}\n\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction<T extends TypedContract, FN extends ContractFunctionNames<T>>(\n  contract: T | Falsy,\n  functionName: FN,\n  options?: TransactionOptions\n) {\n  const { library, chainId } = useEthers()\n  const transactionChainId = (options && 'chainId' in options && options?.chainId) || chainId\n  const { promiseTransaction, state, resetState } = usePromiseTransaction(transactionChainId, options)\n  const [events, setEvents] = useState<LogDescription[] | undefined>(undefined)\n\n  const config = useConfig()\n  const gasLimitBufferPercentage =\n    options?.gasLimitBufferPercentage ?? options?.bufferGasLimitPercentage ?? config?.gasLimitBufferPercentage ?? 0\n\n  const providers = useReadonlyNetworks()\n  const provider = (transactionChainId && providers[transactionChainId as ChainId])!\n\n  const send = useCallback(\n    async (...args: Params<T, FN>): Promise<TransactionReceipt | undefined> => {\n      if (contract) {\n        const hasOpts = args.length > (contract.interface?.getFunction(functionName).inputs.length ?? 0)\n\n        const signer = getSignerFromOptions(provider as providers.BaseProvider, options, library)\n\n        const contractWithSigner = connectContractToSigner(contract, options, signer)\n        const opts = hasOpts ? args[args.length - 1] : undefined\n\n        const gasLimit = await estimateContractFunctionGasLimit(\n          contractWithSigner,\n          functionName,\n          args,\n          gasLimitBufferPercentage\n        )\n\n        const modifiedOpts = {\n          ...opts,\n          gasLimit,\n        }\n        const modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args\n        modifiedArgs.push(modifiedOpts)\n\n        const receipt = await promiseTransaction(contractWithSigner[functionName](...modifiedArgs))\n        if (receipt?.logs) {\n          const events = receipt.logs.reduce((accumulatedLogs, log) => {\n            try {\n              return log.address.toLowerCase() === contract.address.toLowerCase()\n                ? [...accumulatedLogs, contract.interface.parseLog(log)]\n                : accumulatedLogs\n            } catch (_err) {\n              return accumulatedLogs\n            }\n          }, [] as LogDescription[])\n          setEvents(events)\n        }\n        return receipt\n      }\n    },\n    [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]\n  )\n\n  return { send, state, events, resetState }\n}\n"]},"metadata":{},"sourceType":"module"}