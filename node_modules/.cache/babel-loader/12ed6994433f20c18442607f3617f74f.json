{"ast":null,"code":"import { ethers } from 'ethers';\nexport const getSignerFromOptions = (provider, options, library) => {\n  const privateKey = options && 'privateKey' in options && options.privateKey;\n  const mnemonicPhrase = options && 'mnemonicPhrase' in options && options.mnemonicPhrase;\n  const json = options && 'json' in options && options.json;\n  const password = options && 'password' in options && options.password;\n  const privateKeySigner = privateKey && provider && new ethers.Wallet(privateKey, provider);\n  const mnemonicPhraseSigner = mnemonicPhrase && provider && ethers.Wallet.fromMnemonic(mnemonicPhrase).connect(provider);\n  const encryptedJsonSigner = json && password && provider && ethers.Wallet.fromEncryptedJsonSync(json, password).connect(provider);\n  const optionsSigner = options && 'signer' in options && options.signer;\n  return privateKeySigner || mnemonicPhraseSigner || encryptedJsonSigner || optionsSigner || (library === null || library === void 0 ? void 0 : library.getSigner());\n};","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,QAAkC,QAAlC;AAMA,OAAO,MAAMC,oBAAoB,GAAG,CAClCC,QADkC,EAElCC,OAFkC,EAGlCC,OAHkC,KAIhC;EACF,MAAMC,UAAU,GAAGF,OAAO,IAAI,gBAAgBA,OAA3B,IAAsCA,OAAO,CAACE,UAAjE;EACA,MAAMC,cAAc,GAAGH,OAAO,IAAI,oBAAoBA,OAA/B,IAA0CA,OAAO,CAACG,cAAzE;EACA,MAAMC,IAAI,GAAGJ,OAAO,IAAI,UAAUA,OAArB,IAAgCA,OAAO,CAACI,IAArD;EACA,MAAMC,QAAQ,GAAGL,OAAO,IAAI,cAAcA,OAAzB,IAAoCA,OAAO,CAACK,QAA7D;EAEA,MAAMC,gBAAgB,GAAGJ,UAAU,IAAIH,QAAd,IAA0B,IAAIF,MAAM,CAACU,MAAX,CAAkBL,UAAlB,EAA8BH,QAA9B,CAAnD;EACA,MAAMS,oBAAoB,GACxBL,cAAc,IAAIJ,QAAlB,IAA8BF,MAAM,CAACU,MAAP,CAAcE,YAAd,CAA2BN,cAA3B,EAA2CO,OAA3C,CAAmDX,QAAnD,CADhC;EAEA,MAAMY,mBAAmB,GACvBP,IAAI,IAAIC,QAAR,IAAoBN,QAApB,IAAgCF,MAAM,CAACU,MAAP,CAAcK,qBAAd,CAAoCR,IAApC,EAA0CC,QAA1C,EAAoDK,OAApD,CAA4DX,QAA5D,CADlC;EAGA,MAAMc,aAAa,GAAGb,OAAO,IAAI,YAAYA,OAAvB,IAAkCA,OAAO,CAACc,MAAhE;EAEA,OAAOR,gBAAgB,IAAIE,oBAApB,IAA4CG,mBAA5C,IAAmEE,aAAnE,KAAoFZ,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEc,SAAT,EAApF,CAAP;AACD,CAnBM","names":["ethers","getSignerFromOptions","provider","options","library","privateKey","mnemonicPhrase","json","password","privateKeySigner","Wallet","mnemonicPhraseSigner","fromMnemonic","connect","encryptedJsonSigner","fromEncryptedJsonSync","optionsSigner","signer","getSigner"],"sources":["/Users/qianyisheng/Desktop/web3/brownie_test/brownie_fund_me/front_end/node_modules/@usedapp/core/src/helpers/getSignerFromOptions.ts"],"sourcesContent":["import { ethers, providers } from 'ethers'\nimport { TransactionOptions } from '../model'\n\ntype BaseProvider = providers.BaseProvider\ntype JsonRpcProvider = providers.JsonRpcProvider\n\nexport const getSignerFromOptions = (\n  provider: BaseProvider,\n  options?: TransactionOptions,\n  library?: JsonRpcProvider\n) => {\n  const privateKey = options && 'privateKey' in options && options.privateKey\n  const mnemonicPhrase = options && 'mnemonicPhrase' in options && options.mnemonicPhrase\n  const json = options && 'json' in options && options.json\n  const password = options && 'password' in options && options.password\n\n  const privateKeySigner = privateKey && provider && new ethers.Wallet(privateKey, provider)\n  const mnemonicPhraseSigner =\n    mnemonicPhrase && provider && ethers.Wallet.fromMnemonic(mnemonicPhrase).connect(provider)\n  const encryptedJsonSigner =\n    json && password && provider && ethers.Wallet.fromEncryptedJsonSync(json, password).connect(provider)\n\n  const optionsSigner = options && 'signer' in options && options.signer\n\n  return privateKeySigner || mnemonicPhraseSigner || encryptedJsonSigner || optionsSigner || library?.getSigner()\n}\n"]},"metadata":{},"sourceType":"module"}